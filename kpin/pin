#! /usr/bin/env python3

import argparse
import boto3
import re
import semver
import functools
import sys

from typing import Dict, List, Tuple, Callable

ProjectVersionArg = Tuple[str, str]


class Image:
    __pin_prefix = 'pin-'
    __version_prefix = 'version-'

    def __init__(self, client, payload: Dict):
        self.client = client

        self.name = payload['repositoryName']
        self.digest = payload['imageDigest']
        self.versions = []
        self.pins = []
        self.__manifest = None

        for tag in payload['imageTags']:
            if tag.startswith(self.__version_prefix):
                self.versions.append(tag.lstrip(self.__version_prefix))
            elif tag.startswith(self.__pin_prefix):
                self.pins.append(tag.lstrip(self.__pin_prefix))

    def get_manifest(self) -> str:
        if self.__manifest is None:
            self.__manifest = self.client.get_image_details(self)['imageManifest']

        return self.__manifest

    def add_pin(self, pin: str):
        if pin in self.pins:
            raise ValueError('Pin {} already exists!'.format(pin))
        self.client.put_image_tag(self, 'pin-' + pin)
        self.pins.append(pin)


class Repository:
    __tag_version_prefix = 'version-'

    def __init__(self, client, payload: Dict):
        self.client = client

        self.__name = payload['repositoryName']

        self.__images = None

    def __str__(self) -> str:
        return self.__name

    def get_images(self) -> List[Image]:
        if self.__images is None:
            self.__images = self.client.get_images_for_repository(self.__name)

        return self.__images

    def get_images_by_property(self, prop: str) -> Dict[str, Image]:
        output = dict()

        for image in self.get_images():
            for item in getattr(image, prop):
                output[item] = image

        return output


class Client:
    def __init__(self):
        self.__client = boto3.client('ecr')
        """ :type: pyboto3.ecr """

    def get_repositories(self, names: List[str] = None) -> List[Repository]:
        args = {}

        if names:
            args['repositoryNames'] = names

        response = self.__client.describe_repositories(**args)
        return [Repository(self, r) for r in response['repositories']]

    def get_images_for_repository(self, name: str) -> List[Image]:
        response = self.__client.describe_images(repositoryName=name, filter={'tagStatus': 'TAGGED'})
        return [Image(self, i) for i in response['imageDetails']]

    def get_image_details(self, image: Image) -> dict:
        return self.__client.batch_get_image(
            repositoryName=image.name,
            imageIds=[
                {'imageDigest': image.digest}
            ]
        )['images'][0]

    def put_image_tag(self, image: Image, tag: str):
        self.__client.put_image(repositoryName=image.name, imageManifest=image.get_manifest(), imageTag=tag)


class Output:
    def __init__(self):
        self.pretty = sys.stdout.isatty()

    # TODO: Move filter out
    def list_versions(self, repository: Repository, filter: Callable = None):
        versions = repository.get_images_by_property('versions')

        comparator = functools.cmp_to_key(semver.compare)

        buffer = []
        for version, image in sorted(versions.items(), key=lambda key: comparator(key[0])):
            if filter is not None and not filter(image):
                continue

            if image.pins:
                buffer.append('{} ({})'.format(version, ' '.join(image.pins)))
            else:
                buffer.append('{}'.format(version))

        if buffer:
            if self.pretty:
                print('{}:\n  '.format(repository) + '\n  '.join(buffer) + '\n')
            else:
                print('{}: '.format(repository) + '\n{}: '.format(repository).join(buffer))


class Commands:
    def __init__(self, client: Client, output: Output):
        self.client = client
        self.output = output

    def show_versions(self, repositories: List[str]):
        repositories = self.client.get_repositories(repositories)

        for repo in sorted(repositories, key=lambda k: str(k)):
            self.output.list_versions(repo)

    def list_pins(self, environments: List[str] = None):
        repositories = self.client.get_repositories()

        for repo in sorted(repositories, key=lambda k: str(k)):
            if environments:
                self.output.list_versions(repo, lambda x: [True for pin in x.pins if pin in environments])
            else:
                self.output.list_versions(repo, lambda x: x.pins)

    def set_pins(self, environment: str, projects: List[ProjectVersionArg]):
        repositories = self.client.get_repositories()

        for project, version in projects:
            for repo in repositories:
                if str(repo) == project or str(repo).startswith(project + '-'):
                    versions = repo.get_images_by_property('versions')
                    pins = repo.get_images_by_property('pins')

                    try:
                        new_image = versions[version]
                    except KeyError:
                        print("Version {} not found for {}! Skipping.".format(version, repo))
                        continue

                    if environment in new_image.pins:
                        print(repo, 'is already tagged for', environment)
                        continue

                    new_image.add_pin('pin-' + environment)
                    print('Pinned {} to {}!'.format(repo, version))

                    try:
                        current_image = pins[environment]
                        current_image.add_pin(environment + '-old')
                    except KeyError:
                        print("No image to pin with {}-old".format(environment))

                    try:
                        old_image = pins[environment + '-old']
                        old_image.add_pin(environment + '-old-old')
                    except KeyError:
                        print("No image to pin with {}-old-old".format(environment))


def project_version(arg: str) -> ProjectVersionArg:
    project, version = arg.split('@')
    if not re.compile('^[A-Za-z0-9_.\-]+$').fullmatch(project):
        raise ValueError("{} is not a valid project name".format(project))
    semver.parse(version)
    return project, version


def main():
    commands = Commands(Client(), Output())

    parser = argparse.ArgumentParser()

    subparsers = parser.add_subparsers(title='Commands', metavar=None)

    set_parser = subparsers.add_parser('set', help='Set pins')
    set_parser.set_defaults(func=lambda e: commands.set_pins(e.ENVIRONMENT, e.PROJECT))
    set_parser.add_argument('ENVIRONMENT', help='Environment pin to add')
    set_parser.add_argument('PROJECT', nargs='+', type=project_version, help='Project to pin: project@semver')

    list_parser = subparsers.add_parser('show', help='Show pins')
    list_parser.set_defaults(func=lambda e: commands.list_pins(e.ENVIRONMENT))
    list_parser.add_argument('ENVIRONMENT', nargs='*', help='Environment to list pins from')

    versions_parser = subparsers.add_parser('list-versions', help='List available versions')
    versions_parser.set_defaults(func=lambda p: commands.show_versions(p.PROJECT))
    versions_parser.add_argument('PROJECT', nargs='*')

    # auto-help
    if not sys.argv[1:]:
        sys.argv.insert(1, '-h')

    args = parser.parse_args()

    if hasattr(args, 'func'):
        args.func(args)


if __name__ == '__main__':
    main()
